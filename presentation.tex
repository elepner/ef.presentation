
\documentclass{bredelebeamer}
\input{cslistings.tex}
\usepackage{tikz}
\title[EFC Tips \& Tricks]{Entity Framework Core: Tips and Tricks}

% \subtitle{Some subtitle}

\author{Eduard Lepner\inst{1}}
\institute[Powel]
{
  \inst{1}%
  Powel AS\\
  Team Leader at Powel Water
  }


\date{April 2018}

\subject{EF Core: Tips and Tricks}
% Goes to PDF Metadata

\logo{
\includegraphics[scale=0.10]{images/logo.jpg}
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% \begin{frame}{Table of contents}
%   \tableofcontents
% \end{frame}




\section{Theory}

\begin{frame} {About Entity Framework}
    \begin{columns}[t]
        \begin{column}{0.5\textwidth}
            Queries\\[.2cm]
            \begin{enumerate}
                \item Queries (Where clauses, Take, Skip, OrderBy)
                \item Projections (Select statement)
                \item Aggregate (Min, Max, GroupBy)
            \end{enumerate}
            \onslide<2->{
                \begin{itemize}
                    \item Expression analysis
                    \item Expression translations
                    \item SQL Builder
                \end{itemize}
            }
            
        \end{column}
        \begin{column}{0.5\textwidth}
            Commands\\[.2cm]
            \begin{enumerate}
                \item Create
                \item Read
                \item Update
                \item Delete
            \end{enumerate}
            \onslide<3->{
                    \begin{itemize}
                        \item Dynamic Proxies
                        \item Changes Detection (Object graph tracking)
                    \end{itemize}
                }
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Expression Trees}
    \begin{block}{Any valid OO, Procedural, Declarative or Functional code}
        can be translated to an Abstract Syntax Tree (AST)...
        \pause  ... aaaand vice versa
    \end{block}
    \pause
    \begin{block}{AST}
        is a language indepent abstraction \pause (that's why FP is cool)
    \end{block}
    \pause
    \begin{block}{Expression Tree}
        is an AST. Expression yields one value and AST may represent entire program
    \end{block}
    
    \begin{alertblock}{Bingo!}
        Language A $\Rightarrow$ AST $\Rightarrow$ Language B
    \end{alertblock}
\end{frame}

\begin{frame}[fragile]{Simple State}
    \begin{lstlisting}
var query = dbContext.Posts
    .Where(x => x.Content.StartsWith("Some") || x.Title.Length > 10)
    .Select(x => new { x.Id, x.Title, x.Content })
    \end{lstlisting}
    \pause
    \begin{lstlisting}
var query2 = Queryable.Select(
    Queryable.Where(
        dbContext.Posts, x => x.Content.StartsWith("Some") || x.Title.Length > 10),
    x => new { x.Id, x.Title, x.Content })
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{C\# Syntax Sugar}
    \begin{onlyenv}<1>
        \begin{lstlisting}
        var query = from ac in _context.AddressConnection
            join cp in _context.ConsumptionPlace on ac.AddressObjectID equals cp.Id
            join cc in _context.CustomerConnection on cp.Id equals cc.CustomerObjectID
            join cu in _context.Customer on cc.CustomerID equals cu.Id
            where ac.AddressObjectTable == nameof(ConsumptionPlace) && ac.AddressID == id &&
            cc.CustomerObjectTable == nameof(ConsumptionPlace) && cc.CustomerRoleCode == CustomerRoleCodes.Consumer
            select new ViewModels.ConsumptionPlacePanelView
            {
                Id = cp.Id,
                Name = cu.Name
            };
        \end{lstlisting}
    \end{onlyenv}
    \begin{onlyenv}<2>
        \begin{lstlisting}
        var query = _context.AddressConnection
            .Join(_context.ConsumptionPlace, ac => ac.AddressObjectID, cp => cp.Id, (ac, cp) => new {ac, cp})
            .Join(_context.CustomerConnection, t => t.cp.Id, cc => cc.CustomerObjectID, (t, cc) => new {t, cc})
            .Join(_context.Customer, t => t.cc.CustomerID, cu => cu.Id, (t, cu) => new {t, cu})
            .Where(t => t.t.t.ac.AddressObjectTable == nameof(ConsumptionPlace) && t.t.t.ac.AddressID == id &&
                         t.t.cc.CustomerObjectTable == nameof(ConsumptionPlace) &&
                         t.t.cc.CustomerRoleCode == CustomerRoleCodes.Consumer)
            .Select(t => new ViewModels.ConsumptionPlacePanelView {Id = t.t.t.cp.Id, Name = t.cu.Name});
        \end{lstlisting}
    \end{onlyenv}
\end{frame}
\begin{frame}{IEnumerable<T> vs IQueryble<T>}
    \lstinline{DbSet<T>} implements both \lstinline{IEnumerable<T>} and \lstinline{IQueryble<T>}.
    How does it know which \lstinline{Select, Where, FirstOrDefault} to use?
    \pause
    \begin{exampleblock}{7.5.3.5 Better conversion target}
        Given two different types T1 and T2, T1 is a better conversion target than T2 if at least one of the following holds:
        \begin{itemize}
            \item An implicit conversion from T1 to T2 exists, and no implicit conversion from T2 toT1 exists
            \item T1 is a signed integral type and T2 is an unsigned integral type.
        \end{itemize}
    \end{exampleblock}
    \begin{exampleblock}{Lambda Expressions}
        A lambda expression is an anonymous function that you can use to create delegates or expression tree types. By using lambda expressions, you can write local functions that can be passed as arguments or returned as the value of function calls.
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Expression Parsing}
    \begin{lstlisting}
dbContext.Posts.Where(x => x.Content.StartsWith("Some") || x.Title.Length > 10).Select(x => new { x.Id, x.Title, x.Content })
    \end{lstlisting}
    \includegraphics[height=0.7\textheight]{images/tree.pdf}
\end{frame}

\begin{frame}[fragile]{Conclusions}
    \begin{itemize}
        \item<1-> EF is not magic
        \item<2-> One can pass around Query object append/modify it's nodes (aka Where/Select/OrderBy)
        \item<3-> { This code is not equivalent
        \begin{columns}
            \begin{column}{0.5\textwidth}
                \begin{lstlisting}
new Clazz{A = "A", B = "B"}
                \end{lstlisting}
            \end{column}
            \begin{column}{0.5\textwidth}
                \begin{lstlisting}
var c = new Clazz();
c.A = "A";
c.B = "B";
                \end{lstlisting}
            \end{column}
        \end{columns}
        }
    \end{itemize}
\end{frame}

\section{Level Easy}

\begin{frame}{Projectsion (ViewModels)}
    \begin{onlyenv}<1>
        \lstinputlisting{resources/model.cs}
    \end{onlyenv}
    \begin{onlyenv}<2>
        \lstinputlisting{resources/viewmodel.cs}
    \end{onlyenv}
    
\end{frame}

\begin{frame}[fragile]{Projections}
    \begin{onlyenv}<1>
        \begin{lstlisting}
var query = dbContext.Authors.Include(x => x.Posts).Select(x => new ViewModels.Author
{
    Id = x.Id,
    Name = x.Name + " " + x.LastName,
}).Where(authorView => authorView.Id != 5)
        \end{lstlisting}
    \end{onlyenv}
    \begin{onlyenv}<2>
        \begin{lstlisting}
var query = dbContext.Authors.Include(x => x.Posts).Select(x => new ViewModels.Author
        {
            Id = x.Id,
            Name = x.Name + " " + x.LastName,
            Posts = x.Posts.Select(y => y.Id).ToList()
        }).Where(authorView => authorView.Id != 5)
                .OrderBy(autoryView => autoryView.Name)
    .ToArray();
        \end{lstlisting}
        \begin{alertblock}{Important}
            Nested property translation only after EFC 2.1.0-preview1
        \end{alertblock}
    \end{onlyenv}
\end{frame}
\begin{frame}[fragile]{Projections (SQL Result)}
    \begin{lstlisting}[language=SQL]
        SELECT [t].[c], [t].[Id], [t].[Name], [t].[LastName], [x.Posts].[Id], [x.Posts].[AuthorId]
        FROM [Posts] AS [x.Posts]
        INNER JOIN (
            SELECT ([x0].[Name] + N' ') + [x0].[LastName] AS [c], [x0].[Id], [x0].[Name], [x0].[LastName]
            FROM [Authors] AS [x0]
            WHERE [x0].[Id] <> 5
        ) AS [t] ON [x.Posts].[AuthorId] = [t].[Id]
        ORDER BY [t].[c], [t].[Id]
    \end{lstlisting}
\end{frame}

\begin{frame}{C\# Triggers}
    \lstinputlisting[firstline=44, lastline=56]{../EF.Experiments/EF.Experiments.Data/BloggingContext.cs}
    \pause
    Don't forget to override Async verion of SaveChanges on EF Core.
\end{frame}
\begin{frame}{Object Tracking}
    \lstinputlisting[firstline=29, lastline=31]{../EF.Experiments/EF.Experiments/Program.cs}

    \pause
    \begin{exampleblock}{}
        True
    \end{exampleblock}
\end{frame}

\section{Medium Level}
\begin{frame}{Pattern Specification}
    
\end{frame}

\end{document}
